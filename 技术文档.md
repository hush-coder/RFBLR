# 项目概述

## 目标

构建支持 RISC-V 和 LoongArch 的跨平台编译器

核心特性

+ 基于 **Rust** 的内存安全前端（Flex/Bison 生成器）
+ LLVM 毕昇分支优化 
+ 支持 RISC-V V 扩展与 LoongArch 基础指令集

# 架构

## 流程图

graph LR
  A[源码输入] --> B(Flex词法分析器)
  B --> C(Bison语法解析器)
  C --> D[Rust AST绑定层]
  D --> E[语义分析与类型检查]
  E --> F[inkwell生成LLVM IR]
  F --> G{毕昇LLVM优化Pass}
  G --> H[RISCV代码生成器]
  G --> I[LoongArch扩展模块]

## 前端实现细节

### Flex/Bison与Rust FFI桥接

Flex/Bison生成C文件之后，使用**bindgen**创建Rust接口

```rust
bindgen::Builder::default()
  .header("src/ffi/parser.hpp")
  .generate_comments(false)
  .derive_default(true)
  .allowlist_type("ASTNode.*")
  .allowlist_function("yyparse")
  .parse_callbacks(Box::new(bindgen::CargoCallbacks))
  .generate()
  .unwrap()
  .write_to_file("src/ffi/parser_ffi.rs");
```
### Rust驱动的语义分析

基于Rust的枚举类型实现联合类型推导：

#### AST节点结构定义

首先定义抽象语法树节点的数据结构：

```rust
// 定义一个枚举类型，覆盖所有可能的表达式类型
enum Expr {
    Literal(i64),           // 数字字面量 如 42
    Variable(String),       // 变量名 如 x
    BinaryOp(Box<Expr>, BinaryOperator, Box<Expr>), // 操作符 如 a + b
    FunctionCall(String, Vec<Expr>), // 函数调用 如 add(3,5)
}
// 支持的操作符类型
enum BinaryOperator {
    Add, Subtract, Multiply, Divide,
    Equal, NotEqual, // 等等...
}
```

#### 符号收集

```rust
struct SymbolCollector {
    current_scope: HashMap<String, SymbolInfo>, // 当前作用域符号表
    parent_scopes: Vec<HashMap<String, SymbolInfo>>, // 父级作用域栈
}

impl SymbolCollector {
    fn visit_function(&mut self, func: &Function) {
        // 登记函数名
        self.current_scope.insert(func.name.clone(), SymbolType::Function);
        // 进入新作用域（函数体）
        self.parent_scopes.push(self.current_scope.clone());
        self.current_scope = HashMap::new();
        // 登记参数
        for param in &func.params {
            self.current_scope.insert(param.name.clone(), param.typ.clone());
        }
        // 遍历函数体
        for stmt in &func.body {
            self.visit_statement(stmt);
        }
        // 退出作用域
        self.current_scope = self.parent_scopes.pop().unwrap();
    }
}
```

#### 类型检查

```rust
fn check_expr_type(expr: &Expr, ctx: &Context) -> Result<Type, Error> {
    match expr {
        Expr::Literal(_) => Ok(Type::Int), // 数字直接返回整型
        
        Expr::Variable(name) => 
            ctx.lookup(name)  // 查符号表
            .ok_or(Error::UndefinedVariable(name.clone())),
        
        Expr::BinaryOp(left, op, right) => {
            let l_type = check_expr_type(left, ctx)?;
            let r_type = check_expr_type(right, ctx)?;
            
            // 操作符合法性检查
            match op {
                BinaryOperator::Add if l_type == r_type => Ok(l_type),
                BinaryOperator::Equal => Ok(Type::Bool),
                _ => Err(Error::TypeMismatch(op.clone(), l_type, r_type))
            }
        }
        
        // 处理其他表达式类型...
    }
}
```

#### 分析控制流

fn check_returns(func: &Function) -> Result<(), Error> {
    let mut has_return = false;
    
    for stmt in &func.body {
        if let Statement::Return(_) = stmt {
            has_return = true;
        }
    }
    
    if !has_return && func.return_type != Type::Void {
        return Err(Error::MissingReturnValue);
    }
    
    Ok(())
}

## 中端实现细节

### inkwell的LLVM-IR生成

相对于以往的基于C API的IR生成，我们使用inkwell/llvm-sys绑定LLVM C API（Rust安全封装），使用inkwell的高阶API生成基本算术操作：

```rust
fn build_sum_function(context: &Context, module: &Module) {
    let i32_type = context.i32_type();
    
    // 创建函数签名: int sum(int n)
    let fn_type = i32_type.fn_type(&[i32_type.into()], false);
    let function = module.add_function("sum", fn_type, None);
    
    // 创建基本块(Basic Block)
    let entry_block = context.append_basic_block(function, "entry");
    let loop_block = context.append_basic_block(function, "loop");
    let exit_block = context.append_basic_block(function, "exit");
    
    // 生成入口代码：
    let builder = context.create_builder();
    builder.position_at_end(entry_block);
    let total_ptr = builder.build_alloca(i32_type, "total");
    builder.build_store(total_ptr, i32_type.const_int(0, false));
    builder.build_br(loop_block);
    
    // 循环块代码生成：
    builder.position_at_end(loop_block);
    let i_phi = builder.build_phi(i32_type, "i");
    let total_phi = builder.build_phi(i32_type, "total");
    // ... (完整实现需要处理PHI节点)
}
```

### 初始SSA

构建初始SSA形式（通过PHI节点）

### IR层优化

+ 常量传播
+ 循环不变量外提
+ 死代码消除

> 每个优化pass必须维护SSA的完整性

### 针对RISC-V的优化Pass

自定义IR转换规则消除RISC-V不必要的sext.w：

```cpp
// 实现自定义的MachineFunctionPass
class RISCVSExtElim : public MachineFunctionPass {
  bool runOnMachineFunction(MachineFunction &MF) override {
    for (auto &MBB : MF) {
      for (auto &MI : MBB) {
        if (MI.getOpcode() == RISCV::SEXT_W) {
          Register Src = MI.getOperand(0).getReg();
          Register Dest = MI.getOperand(1).getReg();
          // 若Src的宽度已经是32位，则删除sext.w
          if (MRI->getRegClass(Src)->getSize() == 4) {
            MI.eraseFromParent();  
            break;
          }
        }
      }
    }
    return true;
  }
};
```

## 后端实现细节

### 指令选择

将LLVM IR的中间表示映射到RISC-V的具体机器指令

+ **模式匹配：** 使用LLVM的SelectionDAG（有向图）描述指令间的依赖关系，并为每个IR操作符定义对应的RISC-V指令模板。
+ **定义指令：** 在.td文件中声明指令格式和操作数约束

> 对乘除法等复杂操作调用RISC-V的扩展指令（如M扩展中的mulw）。

### 分配寄存器

LLVM IR使用无限虚拟寄存器，需映射到RISC-V的有限物理寄存器（32个通用寄存器）。使用**线性扫描算法**：
1. 统计每个虚拟寄存器从定义到最后一次使用的区间。
2. 优先分配生存期短的寄存器。
3. 临时寄存器（t0-t6） > 保存寄存器（s0-s11）。

### 压缩指令优化 

将标准指令替换为等效的短指令（16位 vs 32位），减少代码体积。

### LoongArch扩展

 1. **指令编码映射：** 继承LLVM的MCCodeEmitter实现LoongArch二进制编码

> LoongArch的指令格式（如3寄存器操作）与RISC-V不同。

 2. **ABI的兼容层：** 根据目标架构选择寄存器映射

> LoongArch的指令格式（如3寄存器操作）与RISC-V不同。
